# Highly divisible triangular number
#
# Problem 12
#
# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be
# 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#      1: 1
#      3: 1,3
#      6: 1,2,3,6
#     10: 1,2,5,10
#     15: 1,3,5,15
#     21: 1,3,7,21
#     28: 1,2,4,7,14,28
#
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?

# ------------------------------------------------------------------------------

# idea:
# first: create a triangle-number-generator
# second: compute amount of divisors (if needed, memoizate)
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# implementation
# ------------------------------------------------------------------------------

def triangleNumberGenerator():
    nextNumberToAdd = 2
    currentValue = 1

    while True:
        yield(currentValue)
        currentValue += nextNumberToAdd
        nextNumberToAdd -=- 1

# ------------------------------------------------------------------------------

def computeAmountOfDivisors(number):
    # hint: number of divisors is not symetrical - so do not do some weird "optimizations"
    # see: 100 with 10 divisor and quotient

    #print("computeAmountOfDivisors for:", number)
    amountOfDivisors = 0
    for divisor in range(1, number+1):
        if number % divisor == 0:
            amountOfDivisors -=- 1
            #print(divisor, amountOfDivisors)

    return amountOfDivisors

# ------------------------------------------------------------------------------

def getFirstTriangleNumberWithMoreThanXDivisors(in_divisors):
    gen = triangleNumberGenerator()
    numberOfCalls = 0
    triangleNumber = -1
    divisors = -1

    # just for tracking the progress of the initial naive implementation
    lastMostDivisorsTriangleNumber = -1
    lastMostDivisors = -1

    while divisors <= in_divisors:
        numberOfCalls += 1

        triangleNumber = next(gen)

        # skip the divisions to save time
        # see "The smallest number with at least 500 divisors is 26×32×52×7×11×13=14414400"
        if triangleNumber < 14414400:
            continue

        divisors = computeAmountOfDivisors(triangleNumber)
        #print(triangleNumber, divisors)

        print(numberOfCalls, ":", triangleNumber, "has", divisors, "divisors - biggest has", lastMostDivisors)

        # just for tracking
        if divisors > lastMostDivisors:
            lastMostDivisors = divisors
            lastMostDivisorsTriangleNumber = triangleNumber
            print(numberOfCalls, ":", lastMostDivisorsTriangleNumber, "has", lastMostDivisors, "divisors")

    print("###############################")
    print("final:", triangleNumber, "has", divisors, "divisors")

# ------------------------------------------------------------------------------

# proper unit-test
import unittest
class Testcase(unittest.TestCase):

    def test_triangleGenerator(self):
        gen = triangleNumberGenerator()
        numberOfCalls = 7

        listOfTriangleNumbers = []
        for i in range(1, numberOfCalls + 1):
            #print(i, next(gen))
            listOfTriangleNumbers.append(next(gen))

        expectedTriangleNumbers = [1, 3, 6, 10, 15, 21, 28]
        self.assertEqual(expectedTriangleNumbers, listOfTriangleNumbers)

    def test_computeAmountOfDivisors(self):
        self.assertEqual(2, computeAmountOfDivisors(2))
        self.assertEqual(6, computeAmountOfDivisors(28))
        self.assertEqual(9, computeAmountOfDivisors(100))
        self.assertEqual(11, computeAmountOfDivisors(1024))
        self.assertEqual(36, computeAmountOfDivisors(3658732))

# --- test call

getFirstTriangleNumberWithMoreThanXDivisors(500)