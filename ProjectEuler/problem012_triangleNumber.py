# Highly divisible triangular number
#
# Problem 12
#
# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be
# 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#      1: 1
#      3: 1,3
#      6: 1,2,3,6
#     10: 1,2,5,10
#     15: 1,3,5,15
#     21: 1,3,7,21
#     28: 1,2,4,7,14,28
#
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?

# ------------------------------------------------------------------------------

# idea:
# first: create a triangle-number-generator
# second: compute amount of divisors (if needed, memoizate)
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# implementation
# ------------------------------------------------------------------------------

def triangleNumberGenerator():
    nextNumberToAdd = 2
    currentValue = 1

    while True:
        yield(currentValue)
        currentValue += nextNumberToAdd
        nextNumberToAdd -=- 1

# ------------------------------------------------------------------------------

def computeAmountOfDivisors(number):
    # hint 0: number of divisors is not symmetrical - so do not do some weird "optimizations"
    # see: 100 with 10: is divisor and quotient
    # remove 1 in case of a true square-number
    # hint 1: memoization looked like an idea, but is wrong, because of permutations
    # (just doing 1 + computeAmountOfDivisors(number // firstDiv) is fast, but wrong!)

    #print("computeAmountOfDivisors for:", number)
    amountOfDivisors = 0
    squareRoot = int(number ** 0.5)
    for divisor in range(1, squareRoot+1):
        if number % divisor == 0:
            amountOfDivisors -=- 2
            #print(divisor, amountOfDivisors)

    # remove one, if it is a perfect square
    # https://www.mathblog.dk/triangle-number-with-more-than-500-divisors/
    if squareRoot * squareRoot == number:
        amountOfDivisors -= 1

    return amountOfDivisors

# ------------------------------------------------------------------------------

def getFirstTriangleNumberWithMoreThanXDivisors(in_divisors):
    import time

    gen = triangleNumberGenerator()
    numberOfCalls = 0
    triangleNumber = -1
    divisors = -1

    # just for tracking the progress of the initial naive implementation
    lastMostDivisorsTriangleNumber = -1
    lastMostDivisors = -1

    while divisors <= in_divisors:
        numberOfCalls += 1

        triangleNumber = next(gen)

        # skip the divisions to save time
        # see "The smallest number with at least 500 divisors is 26×32×52×7×11×13=14414400"
        # if triangleNumber < 14414400:
        #     continue
        #
        # # form previous run: 17907120 has 480
        # if triangleNumber < 17907120:
        #     continue

        if triangleNumber < 31486080:
            continue

        startTime = time.time()
        divisors = computeAmountOfDivisors(triangleNumber)

        print(numberOfCalls, ":", triangleNumber, "has", divisors, "divisors", "(took", time.time() - startTime, "s) /", "biggest has", lastMostDivisors)

        # just for tracking
        if divisors > lastMostDivisors:
            lastMostDivisors = divisors
            lastMostDivisorsTriangleNumber = triangleNumber
            print(numberOfCalls, ":", lastMostDivisorsTriangleNumber, "has", lastMostDivisors, "divisors")

    print("###############################")
    print("final:", triangleNumber, "has", divisors, "divisors")

# ------------------------------------------------------------------------------

# proper unit-test
import unittest
class Testcase(unittest.TestCase):

    def test_triangleGenerator(self):
        gen = triangleNumberGenerator()
        numberOfCalls = 7

        listOfTriangleNumbers = []
        for i in range(1, numberOfCalls + 1):
            #print(i, next(gen))
            listOfTriangleNumbers.append(next(gen))

        expectedTriangleNumbers = [1, 3, 6, 10, 15, 21, 28]
        self.assertEqual(expectedTriangleNumbers, listOfTriangleNumbers)

    def test_computeAmountOfDivisors(self):
        self.assertEqual(2, computeAmountOfDivisors(2))
        self.assertEqual(6, computeAmountOfDivisors(28))
        self.assertEqual(9, computeAmountOfDivisors(100))
        self.assertEqual(11, computeAmountOfDivisors(1024))
        self.assertEqual(36, computeAmountOfDivisors(3658732))

# --- test call

getFirstTriangleNumberWithMoreThanXDivisors(500)

# run:
# ...
# 12371 : 76527006 has 32 divisors (took 0.0 s) / biggest has 448
# 12372 : 76539378 has 16 divisors (took 0.0 s) / biggest has 448
# 12373 : 76551751 has 8 divisors (took 0.0 s) / biggest has 448
# 12374 : 76564125 has 96 divisors (took 0.0 s) / biggest has 448
# 12375 : 76576500 has 576 divisors (took 0.0 s) / biggest has 448
# 12375 : 76576500 has 576 divisors
# ###############################
# final: 76576500 has 576 divisors

#--------------------------
# Congratulations, the answer you gave to problem 12 is correct.
#
# You are the 203380th person to have solved this problem.
#
# This problem had a difficulty rating of 5%. The highest difficulty rating you have solved so far is 20%.
